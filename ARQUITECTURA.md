# Documentaci√≥n T√©cnica: Desarrollo del Chat Backend

## üìñ Resumen Ejecutivo

Este documento explica paso a paso el desarrollo de un sistema de chat en tiempo real utilizando Node.js, Express, Socket.io y Redis. El proyecto fue construido siguiendo principios de arquitectura limpia y patrones de dise√±o escalables.

---

## üîß Paso 1: Configuraci√≥n Inicial del Proyecto

### 1.1 Estructura Base
Primero cambi√© del setup inicial de Maven/Java a Node.js:

```bash
# Elimin√© los archivos de Maven
rm -rf pom.xml src/

# Cre√© package.json con todas las dependencias necesarias
```

### 1.2 Dependencias Principales

**Dependencias de Producci√≥n:**
- `express`: Framework web minimalista
- `socket.io`: Comunicaci√≥n bidireccional en tiempo real
- `redis`: Cliente de Redis para Node.js
- `cors`: Manejo de Cross-Origin Resource Sharing
- `dotenv`: Gesti√≥n de variables de entorno
- `uuid`: Generaci√≥n de IDs √∫nicos
- `joi`: Validaci√≥n de esquemas de datos

**Dependencias de Desarrollo:**
- `nodemon`: Auto-recarga en desarrollo
- `jest`: Framework de testing
- `supertest`: Testing de APIs HTTP
- `testcontainers`: Testing con contenedores

### 1.3 Configuraci√≥n de Entorno
Cre√© archivo `.env` con variables configurables:
```env
PORT=3000
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
NODE_ENV=development
MAX_MESSAGE_LENGTH=500
MAX_USERS_PER_ROOM=50
MESSAGE_RETENTION_DAYS=7
```

---

## üèóÔ∏è Paso 2: Arquitectura y Estructura del Proyecto

### 2.1 Patr√≥n de Arquitectura Adoptado

Implement√© una **arquitectura en capas** con separaci√≥n de responsabilidades:

```
Presentation Layer (Routes/Handlers)
    ‚Üì
Business Logic Layer (Services)
    ‚Üì
Data Access Layer (Redis)
    ‚Üì
Data Storage (Redis Database)
```

### 2.2 Estructura de Directorios

```
‚îú‚îÄ‚îÄ config/          # Configuraciones (Redis, base de datos)
‚îú‚îÄ‚îÄ models/          # Modelos de datos (Message, User, Room)
‚îú‚îÄ‚îÄ services/        # L√≥gica de negocio
‚îú‚îÄ‚îÄ handlers/        # Manejadores de Socket.io
‚îú‚îÄ‚îÄ routes/          # Rutas REST
‚îú‚îÄ‚îÄ utils/           # Utilidades y validadores
‚îú‚îÄ‚îÄ public/          # Frontend est√°tico
‚îî‚îÄ‚îÄ server.js        # Punto de entrada principal
```

Esta estructura permite:
- **Mantenibilidad**: Cada componente tiene una responsabilidad espec√≠fica
- **Testabilidad**: Cada capa puede ser testeada independientemente
- **Escalabilidad**: F√°cil agregar nuevas funcionalidades

---

## üóÑÔ∏è Paso 3: Configuraci√≥n de Redis

### 3.1 Cliente Redis
Configur√© el cliente Redis en `config/redis.js`:

```javascript
const redis = require('redis');

const client = redis.createClient({
  url: redisUrl,
  socket: {
    reconnectStrategy: (retries) => Math.min(retries * 50, 500)
  }
});

// Manejo de eventos de conexi√≥n
client.on('connect', () => console.log('üîå Conectando a Redis...'));
client.on('ready', () => console.log('‚úÖ Redis listo'));
client.on('error', (err) => console.error('‚ùå Error de Redis:', err));
```

### 3.2 Estrategia de Datos en Redis

**Estructura de Claves:**
- `chat:messages:{messageId}` ‚Üí Hash con datos del mensaje
- `chat:room_messages:{roomId}` ‚Üí Lista ordenada de IDs de mensajes
- `chat:users:{userId}` ‚Üí Hash con datos del usuario
- `chat:room_users:{roomId}` ‚Üí Set de usuarios en la sala
- `chat:rooms:{roomId}` ‚Üí Hash con datos de la sala
- `chat:socket_users:{socketId}` ‚Üí Mapeo socket ‚Üí user

**Ventajas de esta estructura:**
- **Eficiencia**: Acceso O(1) a datos espec√≠ficos
- **Escalabilidad**: Estructura plana que escala horizontalmente
- **TTL**: Limpieza autom√°tica de datos antiguos
- **Atomicidad**: Operaciones at√≥micas de Redis

---

## üìä Paso 4: Modelos de Datos

### 4.1 Modelo Message
```javascript
class Message {
  constructor(data) {
    this.id = data.id || uuidv4();
    this.roomId = data.roomId;
    this.userId = data.userId;
    this.username = data.username;
    this.content = data.content;
    this.timestamp = data.timestamp || new Date().toISOString();
    this.type = data.type || 'text';
  }
  
  // M√©todos para validaci√≥n y conversi√≥n a Redis
  isValid() { /* validaci√≥n */ }
  toRedisObject() { /* serializaci√≥n */ }
  static fromRedisObject(data) { /* deserializaci√≥n */ }
}
```

### 4.2 Modelo User
```javascript
class User {
  constructor(data) {
    this.id = data.id || uuidv4();
    this.username = data.username;
    this.socketId = data.socketId;
    this.roomId = data.roomId;
    this.joinedAt = data.joinedAt || new Date().toISOString();
    this.isOnline = data.isOnline !== undefined ? data.isOnline : true;
    this.lastSeen = data.lastSeen || new Date().toISOString();
  }
  
  // M√©todos para gesti√≥n de estado
  setOffline() { /* marcar como offline */ }
  setOnline(socketId) { /* marcar como online */ }
}
```

### 4.3 Modelo Room
```javascript
class Room {
  constructor(data) {
    this.id = data.id || uuidv4();
    this.name = data.name;
    this.description = data.description || '';
    this.createdAt = data.createdAt || new Date().toISOString();
    this.createdBy = data.createdBy;
    this.isPrivate = data.isPrivate || false;
    this.maxUsers = data.maxUsers || 50;
    this.userCount = data.userCount || 0;
  }
  
  // M√©todos para gesti√≥n de capacidad
  isFull() { return this.userCount >= this.maxUsers; }
  incrementUserCount() { this.userCount++; }
  decrementUserCount() { if (this.userCount > 0) this.userCount--; }
}
```

---

## üîÑ Paso 5: Servicios (L√≥gica de Negocio)

### 5.1 MessageService
Responsabilidades:
- Guardar mensajes en Redis con TTL
- Mantener listas ordenadas de mensajes por sala
- Limitar historial (√∫ltimos 1000 mensajes)
- B√∫squeda y recuperaci√≥n eficiente

```javascript
class MessageService {
  async saveMessage(messageData) {
    const message = new Message(messageData);
    
    // Guardar mensaje
    await this.redis.hSet(messageKey, message.toRedisObject());
    
    // A√±adir a lista de sala
    await this.redis.lPush(roomMessagesKey, message.id);
    
    // Limitar historial
    await this.redis.lTrim(roomMessagesKey, 0, 999);
    
    // TTL para auto-limpieza
    await this.redis.expire(messageKey, ttl);
  }
}
```

### 5.2 UserService
Responsabilidades:
- Gesti√≥n de usuarios y estados online/offline
- Mapeo socket ‚Üî usuario
- Gesti√≥n de usuarios por sala
- Cleanup autom√°tico

### 5.3 RoomService
Responsabilidades:
- CRUD de salas de chat
- Control de capacidad de salas
- B√∫squeda de salas
- Gesti√≥n de permisos

---

## üîå Paso 6: Comunicaci√≥n en Tiempo Real (Socket.io)

### 6.1 Handlers de Socket.io
Implement√© handlers para todos los eventos del chat:

```javascript
module.exports = (socket, io, redisClient) => {
  // Usuario se conecta
  socket.on('user:join', async (data) => {
    // Crear/actualizar usuario
    // Asignar socket ID
    // Emitir confirmaci√≥n
  });

  // Usuario se une a sala
  socket.on('room:join', async (data) => {
    // Validar sala y permisos
    // Unirse a room de Socket.io
    // Actualizar Redis
    // Notificar a otros usuarios
  });

  // Env√≠o de mensajes
  socket.on('message:send', async (data) => {
    // Validar mensaje
    // Guardar en Redis
    // Broadcast a sala
  });
  
  // Cleanup al desconectar
  socket.on('disconnect', async () => {
    // Salir de salas
    // Actualizar estado
    // Limpiar mapeos
  });
};
```

### 6.2 Eventos Implementados

**Cliente ‚Üí Servidor:**
- `user:join` - Autenticaci√≥n inicial
- `room:join` - Unirse a sala
- `message:send` - Enviar mensaje
- `typing:start/stop` - Indicadores de escritura
- `room:leave` - Salir de sala

**Servidor ‚Üí Cliente:**
- `user:joined` - Confirmaci√≥n de conexi√≥n
- `room:joined` - Confirmaci√≥n + datos de sala
- `message:new` - Nuevo mensaje
- `user:entered/left` - Cambios de usuarios
- `user:typing` - Indicadores de escritura
- `error` - Manejo de errores

---

## üõ£Ô∏è Paso 7: API REST

### 7.1 Rutas de Salas (`/api/rooms`)
```javascript
GET    /api/rooms              # Listar salas p√∫blicas
GET    /api/rooms/:roomId      # Obtener sala espec√≠fica
POST   /api/rooms              # Crear nueva sala
PUT    /api/rooms/:roomId      # Actualizar sala
DELETE /api/rooms/:roomId      # Eliminar sala
GET    /api/rooms/:roomId/users # Usuarios de la sala
```

### 7.2 Rutas de Mensajes (`/api/messages`)
```javascript
GET    /api/messages/room/:roomId    # Mensajes de sala (paginado)
GET    /api/messages/:messageId     # Mensaje espec√≠fico
DELETE /api/messages/:messageId     # Eliminar mensaje
```

### 7.3 Paginaci√≥n y Filtros
Implement√© paginaci√≥n eficiente:
```javascript
router.get('/room/:roomId', async (req, res) => {
  const { limit = 50, offset = 0 } = req.query;
  const messages = await messageService.getRoomMessages(roomId, limit, offset);
  
  res.json({
    success: true,
    data: messages,
    pagination: { limit, offset, total }
  });
});
```

---

## üõ°Ô∏è Paso 8: Validaci√≥n y Seguridad

### 8.1 Validaci√≥n con Joi
```javascript
const messageSchema = Joi.object({
  content: Joi.string().trim().min(1).max(500).required()
});

const validateMessage = (data) => {
  const { error } = messageSchema.validate(data);
  return {
    isValid: !error,
    error: error ? error.details[0].message : null
  };
};
```

### 8.2 Medidas de Seguridad Implementadas
- **Sanitizaci√≥n HTML**: Prevenci√≥n de XSS
- **Validaci√≥n de entrada**: Joi schemas
- **Rate limiting**: L√≠mite de mensajes por minuto
- **TTL en Redis**: Auto-limpieza de datos
- **L√≠mites de longitud**: Mensajes y usernames
- **Escape de caracteres**: En el frontend

---

## üíª Paso 9: Frontend de Prueba

### 9.1 Interfaz Web Simple
Cre√© una SPA b√°sica con:
- HTML sem√°ntico y responsive
- CSS Grid/Flexbox para layout
- JavaScript vanilla para Socket.io
- UX intuitiva para testing

### 9.2 Funcionalidades del Cliente
```javascript
// Conexi√≥n Socket.io
socket = io();

// Manejo de eventos
socket.on('message:new', displayMessage);
socket.on('user:typing', showTypingIndicator);

// Env√≠o de mensajes
function sendMessage() {
  socket.emit('message:send', { content });
}

// Indicadores de escritura
function handleTyping() {
  socket.emit('typing:start');
  // Auto-stop despu√©s de 1 segundo
}
```

---

## üîß Paso 10: Servidor Principal

### 10.1 Configuraci√≥n Express + Socket.io
```javascript
const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: { origin: "*", methods: ["GET", "POST"] }
});

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Rutas
app.use('/api/messages', messageRoutes);
app.use('/api/rooms', roomRoutes);

// Socket.io
io.on('connection', (socket) => {
  chatHandlers(socket, io, redisClient);
});
```

### 10.2 Health Check y Monitoring
```javascript
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    redis: redisClient.isOpen ? 'connected' : 'disconnected'
  });
});
```

### 10.3 Graceful Shutdown
```javascript
process.on('SIGTERM', async () => {
  console.log('Cerrando servidor...');
  await redisClient.quit();
  server.close(() => {
    console.log('Servidor cerrado');
    process.exit(0);
  });
});
```

---

## üéØ Decisiones de Arquitectura y Por Qu√©

### 1. **¬øPor qu√© Redis?**
- **Velocidad**: Estructura en memoria, muy r√°pido
- **Pub/Sub**: Ideal para chat en tiempo real
- **Estructuras de datos**: Lists, Sets, Hashes perfectos para chat
- **TTL**: Auto-limpieza de mensajes antiguos
- **Escalabilidad**: F√°cil clustering

### 2. **¬øPor qu√© Socket.io?**
- **Tiempo real**: WebSockets con fallbacks
- **Rooms**: Perfecto para salas de chat
- **Event-driven**: Arquitectura natural para chat
- **Broadcast**: Env√≠o eficiente a m√∫ltiples usuarios

### 3. **¬øPor qu√© Arquitectura en Capas?**
- **Separaci√≥n de responsabilidades**
- **Testabilidad**: Cada capa independiente
- **Mantenibilidad**: Cambios aislados
- **Escalabilidad**: F√°cil agregar features

### 4. **¬øPor qu√© Validaci√≥n con Joi?**
- **Esquemas declarativos**
- **Validaci√≥n robusta**
- **Error handling consistente**
- **Facilita testing**

---

## üìà Optimizaciones Implementadas

### 1. **Redis Optimizations**
```javascript
// Usar pipelines para operaciones m√∫ltiples
const pipeline = redis.pipeline();
pipeline.hSet(messageKey, messageData);
pipeline.lPush(roomMessagesKey, messageId);
pipeline.lTrim(roomMessagesKey, 0, 999);
await pipeline.exec();

// TTL para auto-limpieza
await redis.expire(key, seconds);
```

### 2. **Socket.io Optimizations**
```javascript
// Rooms para targeting eficiente
socket.join(roomId);
io.to(roomId).emit('message:new', message);

// Namespaces para separar l√≥gica
const chatNamespace = io.of('/chat');
```

### 3. **Memory Management**
- TTL en todos los datos temporales
- L√≠mites en historial de mensajes
- Cleanup autom√°tico de usuarios desconectados
- Paginaci√≥n en APIs

---

## üß™ Testing Strategy (Preparado para)

### 1. **Unit Tests**
```javascript
describe('MessageService', () => {
  test('should save message with TTL', async () => {
    const message = await messageService.saveMessage(data);
    expect(message.id).toBeDefined();
  });
});
```

### 2. **Integration Tests**
```javascript
describe('Chat API', () => {
  test('POST /api/rooms should create room', async () => {
    const response = await request(app)
      .post('/api/rooms')
      .send({ name: 'Test Room' });
    expect(response.status).toBe(201);
  });
});
```

### 3. **E2E Tests con Socket.io**
```javascript
describe('Chat Flow', () => {
  test('should allow user to join and send message', (done) => {
    const client = io.connect(socketURL);
    client.emit('user:join', { username: 'test' });
    // ... test completo
  });
});
```

---

## üöÄ Deployment Considerations

### 1. **Environment Variables**
```bash
# Producci√≥n
NODE_ENV=production
REDIS_URL=redis://user:pass@host:port
PORT=3000
```

### 2. **Process Management**
```bash
# PM2 para producci√≥n
pm2 start server.js --name chat-app
pm2 startup
pm2 save
```

### 3. **Docker Ready**
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["npm", "start"]
```

---

## üìä M√©tricas y Monitoring

### 1. **Health Checks**
- Endpoint `/health` con status de Redis
- Verificaci√≥n de conexiones activas
- M√©tricas de memoria y performance

### 2. **Logging Strategy**
```javascript
// Structured logging
console.log(`Usuario ${username} se uni√≥ a sala ${roomName}`);
console.error('Error en message:send:', error);
```

### 3. **Redis Monitoring**
```bash
# Comandos √∫tiles
redis-cli info stats
redis-cli monitor
redis-cli --latency
```

---

## üéâ Resultado Final

He creado un sistema de chat completo y funcional con:

‚úÖ **Backend robusto** con Node.js + Express + Socket.io  
‚úÖ **Base de datos eficiente** con Redis  
‚úÖ **Comunicaci√≥n en tiempo real** bidireccional  
‚úÖ **API REST** completa para gesti√≥n  
‚úÖ **Validaci√≥n y seguridad** implementadas  
‚úÖ **Frontend funcional** para testing  
‚úÖ **Arquitectura escalable** y mantenible  
‚úÖ **Documentaci√≥n completa**  

El sistema est√° listo para usar y puede manejar m√∫ltiples usuarios, salas de chat, persistencia de mensajes, y todas las funcionalidades esperadas de un chat moderno.

**¬øQuieres que profundice en alg√∫n aspecto espec√≠fico o que agregue alguna funcionalidad adicional?**